<!DOCTYPE html> <html lang="fr"> <head>     <meta charset="UTF-8">     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">     <meta name="theme-color" content="#0f172a">     <meta name="apple-mobile-web-app-capable" content="yes">     <title>WatchParty ðŸŽ¬</title>     <script src="https://cdn.tailwindcss.com"></script>     <style>         @keyframes fadeIn {             from { opacity: 0; transform: translateY(10px); }             to { opacity: 1; transform: translateY(0); }         }         @keyframes fadeInScale {             from { opacity: 0; transform: scale(0.95); }             to { opacity: 1; transform: scale(1); }         }         @keyframes slideInUp {             from { opacity: 0; transform: translateY(100%); }             to { opacity: 1; transform: translateY(0); }         }         @keyframes shimmer {             0% { background-position: -1000px 0; }             100% { background-position: 1000px 0; }         }         .fade-in { animation: fadeIn 0.4s ease-out forwards; }         .fade-in-scale { animation: fadeInScale 0.3s ease-out forwards; }         .slide-up { animation: slideInUp 0.4s ease-out forwards; }         .card-hover {             transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);         }         .card-hover:hover {             transform: translateY(-8px);             box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);         }         .glass-effect {             background: rgba(30, 41, 59, 0.7);             backdrop-filter: blur(12px);             border: 1px solid rgba(255, 255, 255, 0.1);         }         .gradient-text {             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);             -webkit-background-clip: text;             -webkit-text-fill-color: transparent;         }         .shimmer {             background: linear-gradient(90deg, #1e293b 0%, #334155 50%, #1e293b 100%);             background-size: 1000px 100%;             animation: shimmer 2s infinite;         }         * { -webkit-tap-highlight-color: transparent; }         body { overscroll-behavior: contain; }         .star-btn {             transition: transform 0.2s, color 0.2s;         }         .star-btn:active {             transform: scale(1.2);         }     </style> </head> <body class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white min-h-screen">     <div id="app"></div>      <script>         const firebaseConfig = {             apiKey: "AIzaSyBFN56hOHMO0yOOiKxFCr2hU6trRnqf3jQ",             databaseURL: "https://watchpartychou-default-rtdb.europe-west1.firebasedatabase.app"         };          let appState = {             view: 'films',             collection: [],             searchQuery: '',             searchResults: [],             isSearching: false,             isLoading: true,             selectedItem: null,             showModal: false,             modalRating: 0,             showRatingPopup: false,             ratingItem: null,             ratingType: 'movie',             episodeData: null         };          async function loadCollection() {             appState.isLoading = true;             render();             try {                 const response = await fetch(firebaseConfig.databaseURL + '/collection.json');                 const data = await response.json();                 appState.collection = data || [];                 localStorage.setItem('cache', JSON.stringify(appState.collection));             } catch (error) {                 const cache = localStorage.getItem('cache');                 if (cache) appState.collection = JSON.parse(cache);             }             appState.isLoading = false;             render();         }          async function saveCollection() {             try {                 await fetch(firebaseConfig.databaseURL + '/collection.json', {                     method: 'PUT',                     body: JSON.stringify(appState.collection)                 });                 localStorage.setItem('cache', JSON.stringify(appState.collection));             } catch (error) {                 console.error('Erreur:', error);             }         }          async function searchMovies() {             if (!appState.searchQuery) return;             appState.isSearching = true;             appState.searchResults = [];             render();                          try {                 const response = await fetch(`https://www.omdbapi.com/?apikey=b9a5e69d&s=${encodeURIComponent(appState.searchQuery)}`);                 const data = await response.json();                                  if (data.Response === 'True') {                     const promises = data.Search.slice(0, 12).map(item =>                         fetch(`https://www.omdbapi.com/?apikey=b9a5e69d&i=${item.imdbID}`)                             .then(r => r.json())                     );                     appState.searchResults = await Promise.all(promises);                 }             } catch (error) {                 console.error('Erreur:', error);             }                          appState.isSearching = false;             render();         }          function openRatingPopup(item, type = 'movie', episodeData = null) {             appState.ratingItem = item;             appState.ratingType = type;             appState.episodeData = episodeData;             appState.modalRating = 0;             appState.showRatingPopup = true;             render();         }          function submitRating() {             if (!appState.modalRating) return;              const item = appState.ratingItem;              if (appState.ratingType === 'movie') {                 const exists = appState.collection.find(i => i.imdbID === item.imdbID);                 if (!exists) {                     const newItem = {                         imdbID: item.imdbID,                         Title: item.Title,                         Year: item.Year,                         Type: item.Type,                         Poster: item.Poster,                         Plot: item.Plot,                         totalSeasons: item.totalSeasons,                         ourRating: appState.modalRating,                         addedDate: new Date().toISOString(),                         seasons: item.Type === 'series' && item.totalSeasons ?                              Array.from({ length: parseInt(item.totalSeasons) }, (_, i) => ({                                 season: i + 1,                                 episodes: []                             })) : null                     };                     appState.collection.unshift(newItem);                 } else {                     exists.ourRating = appState.modalRating;                 }             } else if (appState.ratingType === 'episode') {                 const seriesItem = appState.collection.find(i => i.imdbID === item.imdbID);                 if (seriesItem && seriesItem.seasons) {                     const season = seriesItem.seasons[appState.episodeData.season - 1];                     const existingEp = season.episodes.find(e => e.episode === appState.episodeData.episode);                                          if (existingEp) {                         existingEp.rating = appState.modalRating;                     } else {                         season.episodes.push({                             episode: appState.episodeData.episode,                             rating: appState.modalRating,                             date: new Date().toISOString()                         });                         season.episodes.sort((a, b) => a.episode - b.episode);                     }                 }             }              saveCollection();             appState.showRatingPopup = false;             appState.modalRating = 0;             render();         }          function deleteItem(imdbID) {             if (confirm('Supprimer cet Ã©lÃ©ment ?')) {                 appState.collection = appState.collection.filter(i => i.imdbID !== imdbID);                 saveCollection();                 render();             }         }          function createStars(rating, size = 24, clickable = false) {             let html = '';             for (let i = 1; i <= 5; i++) {                 const filled = i <= rating;                 const color = filled ? 'text-yellow-400' : 'text-slate-600';                 const click = clickable ? `onclick="appState.modalRating=${i};render()"` : '';                 html += `                     <button ${click} class="star-btn ${color} ${clickable ? 'cursor-pointer' : ''}" style="width:${size}px;height:${size}px;">                         <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${filled ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">                             <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>                         </svg>                     </button>                 `;             }<!DOCTYPE html> <html lang="fr"> <head>     <meta charset="UTF-8">     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">     <meta name="theme-color" content="#0f172a">     <meta name="apple-mobile-web-app-capable" content="yes">     <title>WatchParty ðŸŽ¬</title>     <script src="https://cdn.tailwindcss.com"></script>     <style>         @keyframes fadeIn {             from { opacity: 0; transform: translateY(10px); }             to { opacity: 1; transform: translateY(0); }         }         @keyframes fadeInScale {             from { opacity: 0; transform: scale(0.95); }             to { opacity: 1; transform: scale(1); }         }         @keyframes slideInUp {             from { opacity: 0; transform: translateY(100%); }             to { opacity: 1; transform: translateY(0); }         }         @keyframes shimmer {             0% { background-position: -1000px 0; }             100% { background-position: 1000px 0; }         }         .fade-in { animation: fadeIn 0.4s ease-out forwards; }         .fade-in-scale { animation: fadeInScale 0.3s ease-out forwards; }         .slide-up { animation: slideInUp 0.4s ease-out forwards; }         .card-hover {             transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);         }         .card-hover:hover {             transform: translateY(-8px);             box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);         }         .glass-effect {             background: rgba(30, 41, 59, 0.7);             backdrop-filter: blur(12px);             border: 1px solid rgba(255, 255, 255, 0.1);         }         .gradient-text {             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);             -webkit-background-clip: text;             -webkit-text-fill-color: transparent;         }         .shimmer {             background: linear-gradient(90deg, #1e293b 0%, #334155 50%, #1e293b 100%);             background-size: 1000px 100%;             animation: shimmer 2s infinite;         }         * { -webkit-tap-highlight-color: transparent; }         body { overscroll-behavior: contain; }         .star-btn {             transition: transform 0.2s, color 0.2s;         }         .star-btn:active {             transform: scale(1.2);         }     </style> </head> <body class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white min-h-screen">     <div id="app"></div>      <script>         const firebaseConfig = {             apiKey: "AIzaSyBFN56hOHMO0yOOiKxFCr2hU6trRnqf3jQ",             databaseURL: "https://watchpartychou-default-rtdb.europe-west1.firebasedatabase.app"         };          let appState = {             view: 'films',             collection: [],             searchQuery: '',             searchResults: [],             isSearching: false,             isLoading: true,             selectedItem: null,             showModal: false,             modalRating: 0,             showRatingPopup: false,             ratingItem: null,             ratingType: 'movie',             episodeData: null         };          async function loadCollection() {             appState.isLoading = true;             render();             try {                 const response = await fetch(firebaseConfig.databaseURL + '/collection.json');                 const data = await response.json();                 appState.collection = data || [];                 localStorage.setItem('cache', JSON.stringify(appState.collection));             } catch (error) {                 const cache = localStorage.getItem('cache');                 if (cache) appState.collection = JSON.parse(cache);             }             appState.isLoading = false;             render();         }          async function saveCollection() {             try {                 await fetch(firebaseConfig.databaseURL + '/collection.json', {                     method: 'PUT',                     body: JSON.stringify(appState.collection)                 });                 localStorage.setItem('cache', JSON.stringify(appState.collection));             } catch (error) {                 console.error('Erreur:', error);             }         }          async function searchMovies() {             if (!appState.searchQuery) return;             appState.isSearching = true;             appState.searchResults = [];             render();                          try {                 const response = await fetch(`https://www.omdbapi.com/?apikey=b9a5e69d&s=${encodeURIComponent(appState.searchQuery)}`);                 const data = await response.json();                                  if (data.Response === 'True') {                     const promises = data.Search.slice(0, 12).map(item =>                         fetch(`https://www.omdbapi.com/?apikey=b9a5e69d&i=${item.imdbID}`)                             .then(r => r.json())                     );                     appState.searchResults = await Promise.all(promises);                 }             } catch (error) {                 console.error('Erreur:', error);             }                          appState.isSearching = false;             render();         }          function openRatingPopup(item, type = 'movie', episodeData = null) {             appState.ratingItem = item;             appState.ratingType = type;             appState.episodeData = episodeData;             appState.modalRating = 0;             appState.showRatingPopup = true;             render();         }          function submitRating() {             if (!appState.modalRating) return;              const item = appState.ratingItem;              if (appState.ratingType === 'movie') {                 const exists = appState.collection.find(i => i.imdbID === item.imdbID);                 if (!exists) {                     const newItem = {                         imdbID: item.imdbID,                         Title: item.Title,                         Year: item.Year,                         Type: item.Type,                         Poster: item.Poster,                         Plot: item.Plot,                         totalSeasons: item.totalSeasons,                         ourRating: appState.modalRating,                         addedDate: new Date().toISOString(),                         seasons: item.Type === 'series' && item.totalSeasons ?                              Array.from({ length: parseInt(item.totalSeasons) }, (_, i) => ({                                 season: i + 1,                                 episodes: []                             })) : null                     };                     appState.collection.unshift(newItem);                 } else {                     exists.ourRating = appState.modalRating;                 }             } else if (appState.ratingType === 'episode') {                 const seriesItem = appState.collection.find(i => i.imdbID === item.imdbID);                 if (seriesItem && seriesItem.seasons) {                     const season = seriesItem.seasons[appState.episodeData.season - 1];                     const existingEp = season.episodes.find(e => e.episode === appState.episodeData.episode);                                          if (existingEp) {                         existingEp.rating = appState.modalRating;                     } else {                         season.episodes.push({                             episode: appState.episodeData.episode,                             rating: appState.modalRating,                             date: new Date().toISOString()                         });                         season.episodes.sort((a, b) => a.episode - b.episode);                     }                 }             }              saveCollection();             appState.showRatingPopup = false;             appState.modalRating = 0;             render();         }          function deleteItem(imdbID) {             if (confirm('Supprimer cet Ã©lÃ©ment ?')) {                 appState.collection = appState.collection.filter(i => i.imdbID !== imdbID);                 saveCollection();                 render();             }         }          function createStars(rating, size = 24, clickable = false) {             let html = '';             for (let i = 1; i <= 5; i++) {                 const filled = i <= rating;                 const color = filled ? 'text-yellow-400' : 'text-slate-600';                 const click = clickable ? `onclick="appState.modalRating=${i};render()"` : '';                 html += `                     <button ${click} class="star-btn ${color} ${clickable ? 'cursor-pointer' : ''}" style="width:${size}px;height:${size}px;">                         <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="${filled ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">                             <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>                         </svg>                     </button>                 `;             }
